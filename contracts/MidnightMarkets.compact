pragma language_version 0.16;

import CompactStandardLibrary;

// Enum for the status of an Offer
enum OfferStatus {
    Open,
    Accepted,
    ProofSubmitted,
    FundsReleased,
    Cancelled
}

// Ledger state for the Midnight Markets platform
export ledger owner_id: Uint<32>; // The owner of the Midnight Markets platform
export ledger platform_fee_percentage: Uint<64>; // Percentage for the platform owner (e.g., 100 for 1%)
export ledger sheriff_mode: Uint<8>; // 0 = Free, 1 = Subscription, 2 = NFT mode
export ledger total_markets: Uint<64>; // Total number of markets created
export ledger total_offers: Uint<64>; // Total number of offers made across all markets
export ledger sheriff_names: Map<Bytes<32>, Uint<32>>; // name_hash -> sheriff_nft_id
export ledger total_sheriff_nfts: Uint<64>; // Total Sheriff NFTs minted
export ledger nonce: Counter; // General purpose nonce for state changes
export ledger offer_deposit_timestamps: Map<Uint<32>, Timestamp>; // offer_id -> timestamp of accept_offer
export ledger offer_proof_timestamps: Map<Uint<32>, Timestamp>; // offer_id -> timestamp of submit_proof

// Maps to store market-specific data
export ledger market_sheriffs: Map<Uint<32>, Uint<32>>; // market_id -> sheriff_id (NFT holder)
export ledger market_names: Map<Uint<32>, Bytes<32>>; // market_id -> market_name (arbitrary name designated by Sheriff)
export ledger market_escrow_balances: Map<Uint<32>, Uint<64>>; // market_id -> current escrow balance in $Night tokens
export ledger market_sheriff_fee_percentage: Map<Uint<32>, Uint<64>>; // market_id -> sheriff_fee_percentage (e.g., 100 for 1%)

// Maps to store offer-specific data
export ledger offers: Map<Uint<32>, OfferStatus>; // offer_id -> status of the offer
export ledger offer_market_ids: Map<Uint<32>, Uint<32>>; // offer_id -> market_id where the offer was made
export ledger offer_seller_ids: Map<Uint<32>, Uint<32>>; // offer_id -> seller_id (user posting the offer)
export ledger offer_buyer_ids: Map<Uint<32>, Uint<32>>; // offer_id -> buyer_id (user accepting the offer)
export ledger offer_amounts: Map<Uint<32>, Uint<64>>; // offer_id -> amount in $Night tokens
export ledger offer_details_hashes: Map<Uint<32>, Bytes<32>>; // offer_id -> hash of offer details (for privacy)
export ledger offer_proof_hashes: Map<Uint<32>, Bytes<32>>; // offer_id -> hash of proof details (for privacy)

// Constructor to initialize the Midnight Markets platform
constructor(initial_owner_id: Uint<32>, initial_platform_fee: Uint<64>) {
    owner_id = disclose(initial_owner_id);
    platform_fee_percentage = disclose(initial_platform_fee);
    total_markets = 0;
    total_offers = 0;
    sheriff_mode = 0; // Start in Free mode (Season 1)
    total_sheriff_nfts = 0;
}

// Witness functions for privacy-preserving operations (removed for compilation)
// witness validate_market_name(name_data: Bytes<32>): [Bytes<32>];
// witness validate_offer_details(details_data: Bytes<32>): [Bytes<32>];
// witness validate_proof_details(proof_data: Bytes<32>): [Bytes<32>];
// witness authorize_sheriff_action(sheriff_id: Uint<32>, market_id: Uint<32>, secret: Bytes<32>): [Boolean];

// Batch circuit: Mint Sheriff NFT + Create Market in one txn
export circuit create_market_with_mint(
    market_id: Uint<32>,
    name_hash: Bytes<32>, // SHA-256 hash of full market name
    word_count: Uint<8>, // Number of words for specificity
    is_geo_specific: Boolean, // True for geo premium
    niche_keywords_count: Uint<8>, // Niche discount count
    payment_amount: Uint<64>, // Payment for NFT mint
    market_name: Bytes<32>, // Plain name for storage
    sheriff_fee: Uint<64> // Sheriff's fee percentage
): [] {
    // Uniqueness + pricing from mint
    assert(!sheriff_names.member(disclose(name_hash)), "Market name already taken");

    const base_fee = 10 as Uint<64>;
    const geo_premium = if disclose(is_geo_specific) { 50 as Uint<64> } else { 0 as Uint<64> };
    const niche_discount = (disclose(niche_keywords_count) * 20 as Uint<64>) as Uint<64>;
    const calculated_price = (base_fee + geo_premium - niche_discount) as Uint<64>;
    assert(disclose(payment_amount) >= calculated_price, "Payment insufficient for tiered price");

    // Auto-mint Sheriff NFT ID
    const sheriff_nft_id = (total_sheriff_nfts + 1) as Uint<32>;
    sheriff_names.insert(disclose(name_hash), disclose(sheriff_nft_id));
    total_sheriff_nfts = (total_sheriff_nfts + 1) as Uint<64>;

    // Create market
    assert(!market_sheriffs.member(disclose(market_id)), "Market ID already exists");
    assert(disclose(sheriff_fee) <= 10000, "Sheriff fee percentage too high");

    market_sheriffs.insert(disclose(market_id), disclose(sheriff_nft_id));
    market_names.insert(disclose(market_id), disclose(market_name));
    market_escrow_balances.insert(disclose(market_id), 0 as Uint<64>);
    market_sheriff_fee_percentage.insert(disclose(market_id), disclose(sheriff_fee));

    total_markets = (total_markets + 1) as Uint<64>;
    nonce.increment(1);
}

// Circuit for a non-Sheriff user to post an Offer
export circuit post_offer(
    offer_id: Uint<32>,
    market_id: Uint<32>,
    seller_id: Uint<32>, // User posting the offer
    amount: Uint<64>, // Price in $Night tokens
    offer_details_hash: Bytes<32> // Hash of the offer details for privacy
): [] {
    // Ensure market exists
    assert(market_sheriffs.member(disclose(market_id)), "Market does not exist");
    // Ensure offer_id is unique
    assert(!offers.member(disclose(offer_id)), "Offer ID already exists");
    // Ensure amount is positive
    assert(disclose(amount) > 0, "Offer amount must be positive");

    offers.insert(disclose(offer_id), OfferStatus.Open);
    offer_market_ids.insert(disclose(offer_id), disclose(market_id));
    offer_seller_ids.insert(disclose(offer_id), disclose(seller_id));
    offer_amounts.insert(disclose(offer_id), disclose(amount));
    offer_details_hashes.insert(disclose(offer_id), disclose(offer_details_hash));

    total_offers = (total_offers + 1) as Uint<64>;
    nonce.increment(1);
}

// Circuit for a non-Sheriff user to accept an Offer and place funds into escrow
export circuit accept_offer(
    offer_id: Uint<32>,
    buyer_id: Uint<32>, // User accepting the offer
    market_id: Uint<32>,
    deposited_amount: Uint<64> // Amount of $Night tokens deposited into escrow
): [] {
    // Ensure offer exists and is open
    assert(offers.member(disclose(offer_id)), "Offer does not exist");
    assert(offers.lookup(disclose(offer_id)) == OfferStatus.Open, "Offer is not open for acceptance");
    // Ensure market exists
    assert(market_sheriffs.member(disclose(market_id)), "Market does not exist");
    // Ensure deposited amount matches offer amount
    assert(disclose(deposited_amount) == offer_amounts.lookup(disclose(offer_id)), "Deposited amount does not match offer amount");

    offers.insert(disclose(offer_id), OfferStatus.Accepted);
    offer_buyer_ids.insert(disclose(offer_id), disclose(buyer_id));
    offer_deposit_timestamps.insert(disclose(offer_id), current_timestamp); // Track deposit time

    // Update market escrow balance
    const current_escrow = market_escrow_balances.lookup(disclose(market_id));
    market_escrow_balances.insert(disclose(market_id), (current_escrow + disclose(deposited_amount)) as Uint<64>);

    nonce.increment(1);
}

// Circuit for the seller to submit Proof that the good/service has been provided
export circuit submit_proof(
    offer_id: Uint<32>,
    seller_id: Uint<32>, // The original seller
    proof_hash: Bytes<32> // Hash of the proof details for privacy
): [] {
    // Ensure offer exists and is accepted
    assert(offers.member(disclose(offer_id)), "Offer does not exist");
    assert(offers.lookup(disclose(offer_id)) == OfferStatus.Accepted, "Offer is not in accepted state");
    // Ensure only the seller can submit proof
    assert(offer_seller_ids.lookup(disclose(offer_id)) == disclose(seller_id), "Only the seller can submit proof");

    offers.insert(disclose(offer_id), OfferStatus.ProofSubmitted);
    offer_proof_hashes.insert(disclose(offer_id), disclose(proof_hash));
    offer_proof_timestamps.insert(disclose(offer_id), current_timestamp); // Track proof time

    nonce.increment(1);
}

// Circuit for buyer to refund escrow if seller silent (no proof after 2 weeks)
export circuit buyer_refund_timeout(
    offer_id: Uint<32>,
    buyer_id: Uint<32>
): [] {
    // Ensure offer exists and is accepted (no proof yet)
    assert(offers.member(disclose(offer_id)), "Offer does not exist");
    assert(offers.lookup(disclose(offer_id)) == OfferStatus.Accepted, "Offer not eligible for buyer refund");
    // Ensure caller is buyer
    assert(offer_buyer_ids.lookup(disclose(offer_id)) == disclose(buyer_id), "Only buyer can refund");
    // Timeout: 2 weeks (1,209,600 seconds) from deposit
    const deposit_time = offer_deposit_timestamps.lookup(disclose(offer_id));
    assert(current_timestamp >= deposit_time + 1209600, "Timeout not reached");

    // Refund full escrow to buyer (conceptual—no fee)
    const offer_amount = offer_amounts.lookup(disclose(offer_id));
    const market_id = offer_market_ids.lookup(disclose(offer_id));
    const current_escrow = market_escrow_balances.lookup(disclose(market_id));
    market_escrow_balances.insert(disclose(market_id), (current_escrow - offer_amount) as Uint<64>);

    offers.insert(disclose(offer_id), OfferStatus.Cancelled);
    nonce.increment(1);
}

// Circuit for seller to refund escrow if sheriff silent (no release after proof + 2 weeks)
export circuit seller_refund_timeout(
    offer_id: Uint<32>,
    seller_id: Uint<32>
): [] {
    // Ensure offer exists and proof submitted
    assert(offers.member(disclose(offer_id)), "Offer does not exist");
    assert(offers.lookup(disclose(offer_id)) == OfferStatus.ProofSubmitted, "Offer not eligible for seller refund");
    // Ensure caller is seller
    assert(offer_seller_ids.lookup(disclose(offer_id)) == disclose(seller_id), "Only seller can refund");
    // Timeout: 2 weeks from proof submit
    const proof_time = offer_proof_timestamps.lookup(disclose(offer_id));
    assert(current_timestamp >= proof_time + 1209600, "Timeout not reached");

    // Refund full escrow to seller (conceptual—seller delivered)
    const offer_amount = offer_amounts.lookup(disclose(offer_id));
    const market_id = offer_market_ids.lookup(disclose(offer_id));
    const current_escrow = market_escrow_balances.lookup(disclose(market_id));
    market_escrow_balances.insert(disclose(market_id), (current_escrow - offer_amount) as Uint<64>);

    offers.insert(disclose(offer_id), OfferStatus.Cancelled);
    nonce.increment(1);
}

// Circuit for the Sheriff to release funds from escrow to the seller, and distribute fees
export circuit release_funds(
    offer_id: Uint<32>,
    sheriff_id: Uint<32>, // The Sheriff authorizing the release
    market_id: Uint<32>
): [] {
    // Ensure offer exists and proof has been submitted
    assert(offers.member(disclose(offer_id)), "Offer does not exist");
    assert(offers.lookup(disclose(offer_id)) == OfferStatus.ProofSubmitted, "Proof has not been submitted for this offer");
    // Ensure the market ID matches the offer's market
    assert(offer_market_ids.lookup(disclose(offer_id)) == disclose(market_id), "Offer does not belong to this market");
    // Ensure the authorizing sheriff is the market's sheriff
    assert(market_sheriffs.lookup(disclose(market_id)) == disclose(sheriff_id), "Only the designated Sheriff can release funds for this market");

    // Calculate fees and amounts
    const offer_amount = offer_amounts.lookup(disclose(offer_id));
    const sheriff_fee_percent = market_sheriff_fee_percentage.lookup(disclose(market_id));
    const platform_fee_percent = platform_fee_percentage;

    // Fees are calculated as (amount * percentage) / 10000 (assuming percentage is in basis points, e.g., 100 for 1%)
    const sheriff_fee = (offer_amount * sheriff_fee_percent) / 10000 as Uint<64>;
    const platform_fee = (offer_amount * platform_fee_percent) / 10000 as Uint<64>;
    const amount_to_seller = (offer_amount - sheriff_fee - platform_fee) as Uint<64>;

    // Update market escrow balance (funds are conceptually moved out)
    const current_escrow = market_escrow_balances.lookup(disclose(market_id));
    assert(current_escrow >= offer_amount, "Insufficient funds in escrow");
    market_escrow_balances.insert(disclose(market_id), (current_escrow - offer_amount) as Uint<64>);

    // Conceptually, funds are now distributed:
    // - amount_to_seller goes to offer_seller_ids.lookup(offer_id)
    // - sheriff_fee goes to sheriff_id
    // - platform_fee goes to owner_id
    // (Actual token transfers would be handled by an external token contract interaction)

    offers.insert(disclose(offer_id), OfferStatus.FundsReleased);
    nonce.increment(1);
}

// Circuit for the platform owner to set the global platform fee percentage
export circuit set_platform_fee(
    new_fee: Uint<64>, // New platform fee percentage (e.g., 100 for 1%)
    caller_id: Uint<32> // The caller's ID
): [] {
    // Ensure only the platform owner can set the fee
    assert(disclose(caller_id) == owner_id, "Only the platform owner can set the fee");
    // Ensure new_fee is within reasonable bounds
    assert(disclose(new_fee) <= 10000, "Platform fee percentage too high");

    platform_fee_percentage = disclose(new_fee);
    nonce.increment(1);
}

// Owner-only circuit to change Sheriff mode (0=Free, 1=Subscription, 2=NFT)
export circuit set_sheriff_mode(
    new_mode: Uint<8>, // 0=Free, 1=Subscription, 2=NFT
    caller_id: Uint<32>
): [] {
    assert(disclose(caller_id) == owner_id, "Only platform owner can change Sheriff mode");
    assert(disclose(new_mode) <= 2, "Invalid Sheriff mode");

    sheriff_mode = disclose(new_mode);
    nonce.increment(1);
}

// Circuit for a Sheriff to cancel an open offer in their market
export circuit cancel_offer_by_sheriff(
    offer_id: Uint<32>,
    sheriff_id: Uint<32>,
    market_id: Uint<32>
): [] {
    // Ensure offer exists and is open
    assert(offers.member(disclose(offer_id)), "Offer does not exist");
    assert(offers.lookup(disclose(offer_id)) == OfferStatus.Open, "Offer is not open for cancellation");
    // Ensure the market ID matches the offer's market
    assert(offer_market_ids.lookup(disclose(offer_id)) == disclose(market_id), "Offer does not belong to this market");
    // Ensure the authorizing sheriff is the market's sheriff
    assert(market_sheriffs.lookup(disclose(market_id)) == disclose(sheriff_id), "Only the designated Sheriff can cancel offers in this market");

    offers.insert(disclose(offer_id), OfferStatus.Cancelled);
    nonce.increment(1);
}

// Circuit for a seller to cancel their own open offer
export circuit cancel_offer_by_seller(
    offer_id: Uint<32>,
    seller_id: Uint<32>
): [] {
    // Ensure offer exists and is open
    assert(offers.member(disclose(offer_id)), "Offer does not exist");
    assert(offers.lookup(disclose(offer_id)) == OfferStatus.Open, "Offer is not open for cancellation");
    // Ensure only the seller can cancel their own offer
    assert(offer_seller_ids.lookup(disclose(offer_id)) == disclose(seller_id), "Only the seller can cancel this offer");

    offers.insert(disclose(offer_id), OfferStatus.Cancelled);
    nonce.increment(1);
}
